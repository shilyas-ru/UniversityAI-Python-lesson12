'''
  В этом файле написан код, выполняющий то же самое,
  что и штатная (встроенная) функция map
'''

def calc_map(func, *iterable):
    '''
    Заготовка для теста для функции map
    :param func: пользовательская функция, вызывается для каждого элемента iterable
             функция должна принимать столько аргументов, сколько
             последовательностей передается в функцию map()
    :param iterable: последовательность или объект, поддерживающий итерирование.
             - Если передаются несколько иттераторов, то iterable инициализируется
             кортежем, собержащим все переданные последовательности.
             - Если последовательностей несколько, то пользовательская функция
             func должна принимать количество аргументов, соответствующее количеству
             переданных последовательностей, при этом function будет применяться к
             элементам из всех итераций параллельно.
             - При использовании нескольких последовательностей, функция map()
             останавливается, когда исчерпывается самая короткая итерация.
             Пример:
                 x = [1, 2, 3]
                 y = [4, 5, 6, 7]
                 # вычисление при помощи встроенной функции 'pow()'
                 # 'x' в степени 'y' для каждого элемента 2-х списков
                 list(map(pow, x, y))
             Вывод кода из примера:
                 [1, 32, 729]
             Пояснение:
                 pow(1, 4) == 1
                 pow(2, 5) == 32
                 pow(3, 6) == 729
    :return: объект итератора
    '''
    result_iter = []
    if isinstance(iterable, tuple):
        # Определяем длину самой маленькой последовательности
        min_len = len(iterable[0])
        for i in range(1, len(iterable)):
            min_len = min(min_len, len(iterable[i]))
        # Формируем списки, содержащие элементы всех последовательностей,
        # стоящих на соответствующих номерах.
        # То есть, три последовательности
        # [1, 2, 3], [10, 20, 30, 40, 50], [100, 200, 300, 40]
        # преобразовываем в последовательности
        # [1, 10, 100], [2, 20, 200], [3, 30, 300]
        for i in range(min_len):
            tmp_iter = []
            for el in iterable:
                tmp_iter.append(el[i])
            # Применяем функцию func ко всем элементам последовательности,
            # учитывая длину самой маленькой последоваетльности
            result_iter.append(func(*tmp_iter))
    else:
        min_len = len(iterable)
        for el in iterable:
            result_iter.append(func(el))
    return result_iter


def sum2(a, b):
    return a + b


def sum3(a, b, c):
    return a + b + c


iterable = [[1, 2, 3],
            [10, 20, 30, 40, 50]]

s = calc_map(sum2, *iterable)
print(s)

iterable1 = [1, 2, 3]
iterable2 = [10, 20, 30, 40, 50]

s = calc_map(sum2, iterable1, iterable2)
print(s)

iterable = [[1, 2, 3],
            [10, 20, 30, 40, 50],
            [100, 200, 300, 40]]

s = calc_map(sum3, *iterable)
print(s)

iterable1 = [1, 2, 3]
iterable2 = [10, 20, 30, 40, 50]
iterable3 = [100, 200, 300, 40]

s = calc_map(sum3, iterable1, iterable2, iterable3)
print(s)